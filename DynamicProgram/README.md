# 动态规划

## 写在前面的话
   动态规划问题是计算机编程中经常遇到的一类问题，尽管作为标准的算法工程师，比如语音识别、nlp等领域的工程师，并不经常遇到动态规划的问题，但是作为计算机工程师，或者说编程从业者却是一类需要重点关注的问题。至少有一点，互联网领域内的算法工程师与开发工程师在求职过程中，将会经常与这类问题打交道。
   
   这个项目将会就动态规划问题进行集中的论述。本项目将以典型的动态规划问题依次展开，一方面给出相应问题的解决思路，另一方面给出对应的C/C++代码，同时笔者也会在未来不断丰富该问题相关知识。不足之处，希望您能致函指教（plato.sg.lee@gmail.com）。
   
## 目录
  1、费布那契数列
  
  2、背包问题

## 内容
### 1、费布那契数列
>斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐波那契数列、黄金分割数列。
>在数学上，费波那契数列是以递归的方法来定义：

> * $F_0=0$ 
> * $F_1=1$
> * ...
> * $F_n=F_{n-1}+F_{n-2}$
> * $F_{n}=F_{n-1}+F_{n-2}（n≧2)$ 

>用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：

>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……（OEIS中的数列A000045）

>特别指出：0不是第一项，而是第零项。

根据以上的定义可知，费布那契数列在实现时标准的情况是用递归方法，也就是当我们求Fibonacci的第n个数Fibonacci(n)时，标准情况下用递归即可实现。

但是今天我们用动态规划实现。为什么要以费布那契数列开始讲递归呢？因为费布那契的动态规划解决实际上是最直观的动态规划问题方案，也就是说最能浅显地表达动态规划的思想。

解决方案：
* 目标：求解第n的Fibonacci数列的值；
* 定义dp[i]：表示第i个数Fibonacci数列的值；
* 转移方程：dp[i]=dp[i-1]+dp[i-2], i>=2；
* 边界条件：dp[0]=0,dp[1]=1。

代码实现见[fibonacci.cc](https://github.com/alphaplato/Cplusplus/blob/master/DynamicProgram/fibonacci.cc)。

### 背包问题
#### 01背包
>我们有n种物品，物品j的重量为w[j]，价值为v[j]。
>我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为W。
>如果限定每种物品只能选择0个或1个，则问题称为0-1背包问题。

>可以用公式表示为：

>最大化 $sum_{j=1}^{n}v_{j}x_{j}$
>受限于 $sum_{j=1}^{n}w_{j}x_{j}\quad x_{j} \in {0,1}$


由以上定义可知01背包问题可简述为有一组物品具备不同的重量和价值且唯一，在给定背包载重条件下，求背包可容纳最大的价值。

解决方案：
* 目标：求给定背包载重，求其可容纳最大价值；
* 定义dp[i][j]：前i个物品中在背包载重j时容纳的最大价值；
* 转移方程：dp[i][j]=max{dp[i-1][j] 当j<w[j], dp[i-1][j-w[j]]+v[j] 当j>=w[j]}；
* 边界条件：
1. dp[i][0]=0,当载重为零时；
2. dp[0][j]=0,当j<v[0]，即背包装不进第一个物品时。

#### 无界背包
>如果不限定每种物品的数量，则问题称为无界背包问题。
解决方案：
* 目标：求给定背包载重，求其可容纳最大价值；
* 定义dp[i][]：在背包载重j时容纳的最大价值；
* 转移方程：dp[i]=max{dp[i-w[j] 当i>=w[j]时, 0 当i<w[j]}；
* 边界条件：dp[0]=0。

代码实现见[knapsack.cc](https://github.com/alphaplato/Cplusplus/blob/master/DynamicProgram/knapsack.cc)

