# 排序算法

## 写在前面的话

排序算法是计算常用的算法之一，本项目主要解决排序算法原理与实现问题。

## 目录

1、堆排序

2、快速排序

3、归并排序

## 内容

### 1、堆排序
> 1、堆排序需要用二叉树数据结构实现吗？
> 不需要，堆排序用数组实现。

> 2、什么叫堆？
>堆是一颗完全二叉树；每个结点的值都大于其叶子节点的值称为大顶堆，每个节点的值都小于叶子节点称为小顶堆。

> 3、怎么做堆排序？
>堆排序涉及两个过程：1）建堆；2）拆堆；
>拆堆就意味着建立大顶堆并不代表完成排序；
>两个过程是通过数组完成的。

堆排序涉及建堆、拆堆两个过程。

#### 1、建堆（大顶堆）
> 假设数组a[4,6,8,5,7]，初始化为一个（自然的）完全二叉树，那么其叶子非节点和叶子节点有对应关系，非叶子i的左右子节点分别为2*i+1、2*i+2。 

* 1）从最后一个非叶子节点开始遍历所有节点；
* 2）遍历每个节点同时判断该节点与孩子节点关系是否满足大顶堆要求，满足则继续1)的遍历，不满足则交换值大的叶子和该节点的值使满足堆要求（堆调整），对被交换的子节点继续堆调整直至满足或为叶子节点。

#### 2、拆堆

* 1）从数组的最后一个元素开始遍历到第一个元素；
* 2）遍历每个元素需要完成以下两个步骤：1）交换第一个元素和当前遍历元素；2）调整当前遍历元素之前的所有元素为大顶堆，即对当前遍历之前的数组元素建堆。

堆排序的最佳与平均算法复杂度均为nlog(n)。代码见[heapsort.cc](https://github.com/alphaplato/Cplusplus/blob/master/SortAlgorithm/heapsort.cc)。

ps：堆排序的应用
>100000个数值，找出最大的top10 (topN)。
>1. 取10个数，建小顶堆；
>2. 遍历剩余数，比较数与堆顶数大小，如果大于堆顶，则交换并调整堆。

### 2、快速排序
>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目需要 O(nlogn)次比较。在最坏状况下则需要 $O(n^{2})$次比较，但这种状况并不常见。事实上，快速排序 (nlogn)}通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。

算法步骤：
* 从数列中挑出一个元素，称为“基准”（pivot），
* 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。
* 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

代码实现见[quicksort.cc](https://github.com/alphaplato/Cplusplus/blob/master/SortAlgorithm/quicksort.cc)。

### 3、归并排序
>归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。
>，归并算法的核心是归并操作（merge），指的是将两个已经排序的序列合并成一个序列的操作。

值得注意的是：
* 归并排序采用了分治思想，也可以说是分治最基础的表现算法。
* 归并操作的含义，理解归并二字的含义，自然知道算法怎么实现。

如下图：
![image](https://github.com/alphaplato/Cplusplus/blob/master/image/sortalgorithm-3-1.png)

图示来自Adam Drozdek《c+数据结构与算法》，图示最明显展现出了一下几个特点：
> 1. 从图片上下结构上看，数据的数量为对称结构。
> 2. 从数据次序变化上看，上半结构不断二分法拆分数据，数据次序不变；下半部分不断合并数据，合并的时候将数据顺序排列数据。

因此在递归方法的代码实现上其实也遵循了以上两两条，将代码的递归用分拆（<）、合并(>)两步，并组合嵌套形成递归；而递归的展开即为<<<...>>>的逻辑结构。

代码实现见[mergesort.cc](https://github.com/alphaplato/Cplusplus/blob/master/SortAlgorithm/mergesort.cc)。